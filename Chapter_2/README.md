# Chapter 2 排序
## 2.1 初级排序算法
### 2.1.1
|i|min|0|1|2|3|4|5|6|7|8|9|10|11|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|||E|A|S|Y|Q|U|E|S|T|I|O|N|
|0|1|E|A|S|Y|Q|U|E|S|T|I|O|N|
|1|1|A|E|S|Y|Q|U|E|S|T|I|O|N|
|2|6|A|E|S|Y|Q|U|E|S|T|I|O|N|
|3|9|A|E|E|Y|Q|U|S|S|T|I|O|N|
|4|11|A|E|E|I|Q|U|S|S|T|Y|O|N|
|5|10|A|E|E|I|N|U|S|S|T|Y|O|Q|
|6|11|A|E|E|I|N|O|S|S|T|Y|U|Q|
|7|7|A|E|E|I|N|O|Q|S|T|Y|U|S|
|8|11|A|E|E|I|N|O|Q|S|T|Y|U|S|
|9|11|A|E|E|I|N|O|Q|S|S|Y|U|T|
|10|10|A|E|E|I|N|O|Q|S|S|T|U|Y|
|11|11|A|E|E|I|N|O|Q|S|S|T|U|Y|
### 2.1.2
在选择排序中，一个元素最多会被交换 $N-1$ 次，只有在最大元素排在第一位时才会出现这种情况。
由于每次交换都会有一个元素被放到正确的位置上，所以平均每个元素只会被交换一次。
### 2.1.6
插入排序在元素已经有序的情况下只需要 $N-1$ 次比较和 $0$ 次交换，是一个![](http://latex.codecogs.com/gif.latex?O(N))的算法，而选择排序仍然是一个 $O(N^2)$ 的算法。
### 2.1.7
平方级别。
### 2.1.10
因为在h排序时，数组时部分有序的，部分有序的数组插入排序比选择排序快。
### 2.1.15
**昂贵的交换**  
应该使用选择排序，因为选择排序的交换次数最少。
### 2.1.21
**可比较的交易**  
见[Transaction.hpp](../Chapter_1/Transaction.hpp)。
### 2.1.22
**交易排序测试用例**  
见[SortTransaction](./SortTransaction.cpp)。
### 2.1.24
**插入排序的哨兵**  
在开始插入排序之前找到最小的元素放在数组的开始位置就好。见[InsertionX](./InsertionX.hpp)。
### 2.1.25
**不需要交换的插入排序**  
